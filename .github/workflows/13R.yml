# .github/workflows/build_oneplus_13r.yml
name: Build OnePlus 13R Kernel (KSU+SUSFS)

permissions:
  contents: write # Needed for creating releases/tags and potentially pushing changes (though not done here)
  # actions: write # Generally not needed unless an action explicitly requires it. Keeping contents:write is usually enough.

on:
  workflow_dispatch:
    inputs:
      make_release:
        description: 'Create a GitHub Release with the built kernel?'
        required: true
        type: boolean
        default: true
      release_tag_suffix:
        description: 'Optional suffix for the release tag (e.g., -beta1)'
        required: false
        type: string
        default: ''

# --- Device Specific Configuration ---
# Hardcoded values specific to OnePlus 13R (pineapple)
env:
  MODEL: OP13r
  SOC: pineapple
  BRANCH: oneplus/sm8650
  MANIFEST: oneplus_13r.xml
  ANDROID_VERSION: android14
  KERNEL_VERSION: "6.1"
  ANYKERNEL_BRANCH: "gki-2.0" # Branch for AnyKernel3 (confirm if correct for 6.1)
# --- End Device Specific Configuration ---

jobs:
  build-kernel-op13r:
    # Use a more recent runner image
    runs-on: ubuntu-22.04
    outputs:
      # Make KSU version and zip name available to the release job
      ksu_version: ${{ steps.add_kernelsu.outputs.ksu_version_num }}
      zip_name: ${{ steps.create_zip.outputs.zip_name }}
      build_date: ${{ steps.set_build_date.outputs.build_date }} # Add build date output

    steps:
      - name: Set Build Date
        id: set_build_date
        run: echo "build_date=$(date +%Y%m%d)" >> $GITHUB_OUTPUT

      - name: Maximize Build Space
        run: |
          echo "Initial disk space:"
          df -h
          echo "Removing large packages and directories..."
          # Clean up common large directories
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/.ghcup /opt/hostedtoolcache/CodeQL /usr/local/share/powershell /usr/share/swift || true
          # Clean up Docker images (if any)
          sudo docker image prune --all --force || true
          # Remove large packages (list refined for build environments)
          sudo apt-get purge -y --allow-remove-essential \
            azure-cli ghc* zulu* llvm* firefox google-chrome* dotnet* powershell openjdk* mysql* php* \
            mono* apache* nginx* postgresql* mongodb* redis* || true
          # Aggressive cleanup of apt cache and unused packages
          sudo apt-get autoremove -y
          sudo apt-get clean -y
          echo "Disk space after cleanup:"
          df -h

      - name: Install Build Dependencies
        run: |
          echo "Installing necessary build tools..."
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            git ccache rsync python3 python-is-python3 curl zip unzip \
            libssl-dev bc bison flex libelf-dev kmod libncurses5-dev \
            build-essential wget ca-certificates # Add essential build tools

      - name: Install Repo Tool
        run: |
          echo "Installing Google Repo tool..."
          mkdir -p ~/.local/bin # Ensure the target directory exists
          curl https://storage.googleapis.com/git-repo-downloads/repo > ~/.local/bin/repo
          chmod a+rx ~/.local/bin/repo
          # Add repo to the PATH for this and subsequent steps
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          echo "Repo installed to ~/.local/bin"

      - name: Checkout Required Repositories
        run: |
          echo "Cloning AnyKernel3, SUSFS, and Patches..."
          # Construct SUSFS branch dynamically
          SUSFS_BRANCH="gki-${{ env.ANDROID_VERSION }}-${{ env.KERNEL_VERSION }}"
          echo "Using AnyKernel3 branch: ${{ env.ANYKERNEL_BRANCH }}"
          echo "Using SUSFS branch: $SUSFS_BRANCH"

          git clone --depth=1 https://github.com/TheWildJames/AnyKernel3.git -b "${{ env.ANYKERNEL_BRANCH }}" AnyKernel3
          git clone --depth=1 https://gitlab.com/simonpunk/susfs4ksu.git -b "$SUSFS_BRANCH" susfs4ksu
          git clone --depth=1 https://github.com/TheWildJames/kernel_patches.git kernel_patches

      - name: Initialize and Sync Kernel Source
        run: |
          echo "Creating directory for source: ${{ env.MODEL }}/kernel_platform..."
          # Use the hardcoded MODEL directly for the directory name
          mkdir -p "${{ env.MODEL }}/kernel_platform"
          cd "${{ env.MODEL }}" # Change into the MODEL directory first

          echo "Initializing kernel source repository..."
          # Use hardcoded values from top-level 'env' block
          # Pinning repo version is good practice
          repo init -u https://github.com/OnePlusOSS/kernel_manifest.git -b ${{ env.BRANCH }} -m ${{ env.MANIFEST }} --repo-url=https://github.com/mirror/manifest.git --repo-branch=main --depth=1 --partial-clone --clone-filter=blob:limit=10M

          echo "Repo version:"
          repo version
          echo "Syncing kernel source (this might take a while)..."
          # Optimized sync flags: -c (current branch), -j (parallel jobs), --no-clone-bundle, --no-tags, --optimized-fetch, --prune
          repo sync -c -j$(nproc --all) --no-clone-bundle --no-tags --optimized-fetch --prune --fail-fast

      - name: Add KernelSU-Next
        id: add_kernelsu # Give step an ID to access outputs
        run: |
          KERNEL_PLATFORM_DIR="${{ env.MODEL }}/kernel_platform"
          echo "Changing to kernel platform directory: $KERNEL_PLATFORM_DIR..."
          cd "$KERNEL_PLATFORM_DIR"

          echo "Setting up KernelSU-Next..."
          curl -LSs "https://raw.githubusercontent.com/KernelSU-Next/KernelSU-Next/next/kernel/setup.sh" | bash -s next

          echo "Updating KernelSU submodules..."
          git submodule update --init --recursive KernelSU-Next # Specify the submodule path

          echo "Calculating and setting KSU Version..."
          cd KernelSU-Next/kernel
          # Standard KSU version calculation
          KSU_VERSION=$(expr $(git rev-list --count HEAD) + 10200)
          echo "KSU Version Number: $KSU_VERSION"
          # Set KSUVER for potential use in build scripts (e.g., localversion)
          echo "KSUVER=$KSU_VERSION" >> $GITHUB_ENV
          # Robust sed command to update the Makefile
          sed -i "s/^\(CONFIG_KSU_VERSION=\)\"[0-9]\+\"/\1\"${KSU_VERSION}\"/" Makefile || \
          sed -i "s/DKSU_VERSION=[0-9]\+/DKSU_VERSION=${KSU_VERSION}/" Makefile || \
          echo "Warning: Could not automatically set KSU version in Makefile. Manual check might be needed."

          echo "KSU version set."
          # Export the version number for the job output
          echo "ksu_version_num=${KSU_VERSION}" >> $GITHUB_OUTPUT

      - name: Apply SUSFS Patches
        run: |
          KERNEL_PLATFORM_DIR="${{ env.MODEL }}/kernel_platform"
          echo "Changing to kernel platform directory: $KERNEL_PLATFORM_DIR..."
          cd "$KERNEL_PLATFORM_DIR"

          echo "Applying SUSFS patches..."
          SUSFS_PATCH_NAME="50_add_susfs_in_gki-${{ env.ANDROID_VERSION }}-${{ env.KERNEL_VERSION }}.patch"
          SUSFS_KSU_PATCH_NAME="0001-kernel-patch-susfs-v1.5.5-to-KernelSU-Next-v1.0.5.patch" # Update if SUSFS/KSU versions change

          # Copy SUSFS files/patches (using relative paths from checkout root)
          echo "Copying SUSFS files..."
          cp "../../susfs4ksu/kernel_patches/$SUSFS_PATCH_NAME" ./common/
          # Ensure target directories exist
          mkdir -p ./common/fs/
          mkdir -p ./common/include/linux/
          cp ../../susfs4ksu/kernel_patches/fs/* ./common/fs/
          cp ../../susfs4ksu/kernel_patches/include/linux/* ./common/include/linux/

          echo "Applying SUSFS patch to KernelSU-Next..."
          cd ./KernelSU-Next
          cp "../../../kernel_patches/next/$SUSFS_KSU_PATCH_NAME" ./
          # Use || echo to prevent failure if patch is already applied or fails slightly
          if patch -p1 --forward --dry-run < "$SUSFS_KSU_PATCH_NAME" > /dev/null; then
            patch -p1 --forward < "$SUSFS_KSU_PATCH_NAME"
            echo "SUSFS KSU patch applied successfully."
          else
            echo "SUSFS KSU patch apply attempt finished (may have failed, been skipped, or partially applied)."
          fi

          echo "Applying main SUSFS patch to common kernel..."
          cd ../common
          # Conditional sed specific to 'sun' SOC - will be skipped for 'pineapple'
          if [ "${{ env.SOC }}" == "sun" ]; then
            echo "Applying sun-specific sed command (skipped for ${{ env.SOC }})..."
            # Ensure the line exists before attempting to add below it
            # grep -q '#include <trace/hooks/blk.h>' ./fs/namespace.c && \
            # sed -i '/#include <trace\/hooks\/blk.h>/a #include <trace/hooks/fs.h>' ./fs/namespace.c || \
            # echo "Skipping sun-specific sed: anchor line not found."
          fi
          # Apply main patch with dry run check
          if patch -p1 --forward --dry-run < "$SUSFS_PATCH_NAME" > /dev/null; then
             patch -p1 --forward < "$SUSFS_PATCH_NAME"
             echo "Main SUSFS patch applied successfully."
          else
            echo "Main SUSFS patch apply attempt finished (may have failed, been skipped, or partially applied)."
          fi

      - name: Apply KSU Hooks Patch
        run: |
          KERNEL_COMMON_DIR="${{ env.MODEL }}/kernel_platform/common"
          echo "Changing to common kernel directory: $KERNEL_COMMON_DIR..."
          cd "$KERNEL_COMMON_DIR"
          echo "Applying KSU Hooks patch..."
          KSU_HOOKS_PATCH_NAME="next_hooks.patch"
          cp "../../../kernel_patches/next/$KSU_HOOKS_PATCH_NAME" ./
          # Use || echo and fuzz factor
          if patch -p1 --forward --fuzz=3 --dry-run < "./$KSU_HOOKS_PATCH_NAME" > /dev/null; then
            patch -p1 --forward --fuzz=3 < "./$KSU_HOOKS_PATCH_NAME"
            echo "KSU Hooks patch applied successfully."
          else
            echo "KSU Hooks patch apply attempt finished (may have failed, been skipped, or partially applied)."
          fi

      - name: Apply Hide Stuff Patch
        run: |
          KERNEL_COMMON_DIR="${{ env.MODEL }}/kernel_platform/common"
          echo "Changing to common kernel directory: $KERNEL_COMMON_DIR..."
          cd "$KERNEL_COMMON_DIR"
          echo "Applying Hide Stuff patch..."
          HIDE_STUFF_PATCH_NAME="69_hide_stuff.patch"
          cp "../../../kernel_patches/$HIDE_STUFF_PATCH_NAME" ./
          # Use || echo and fuzz factor
          if patch -p1 --forward --fuzz=3 --dry-run < "$HIDE_STUFF_PATCH_NAME" > /dev/null; then
             patch -p1 --forward --fuzz=3 < "$HIDE_STUFF_PATCH_NAME"
             echo "Hide Stuff patch applied successfully."
          else
            echo "Hide Stuff patch apply attempt finished (may have failed, been skipped, or partially applied)."
          fi

      - name: Add KSU/SUSFS Configuration Settings
        run: |
          KERNEL_PLATFORM_DIR="${{ env.MODEL }}/kernel_platform"
          echo "Changing to kernel platform directory: $KERNEL_PLATFORM_DIR..."
          cd "$KERNEL_PLATFORM_DIR"
          DEFCONFIG_PATH="./common/arch/arm64/configs/gki_defconfig"
          echo "Adding KSU/SUSFS configuration settings to $DEFCONFIG_PATH..."

          # Ensure the target defconfig exists
          if [ ! -f "$DEFCONFIG_PATH" ]; then
            echo "ERROR: $DEFCONFIG_PATH not found!"
            exit 1
          fi

          # Append settings using cat EOF, ensuring not to add duplicates if run multiple times
          # Check for a marker to avoid adding settings repeatedly
          if ! grep -q "# KERNELSU_NEXT_SETTINGS_APPLIED" "$DEFCONFIG_PATH"; then
            cat <<EOF >> $DEFCONFIG_PATH

# KERNELSU_NEXT_SETTINGS_APPLIED - Marker to prevent duplicate additions

# KernelSU Next Settings
CONFIG_KSU=y
CONFIG_KSU_WITH_KPROBES=n # Set based on your preference/compatibility

# SUSFS Settings (Adjust based on desired features)
CONFIG_KSU_SUSFS=y
CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT=y
CONFIG_KSU_SUSFS_SUS_PATH=y
CONFIG_KSU_SUSFS_SUS_MOUNT=y
CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT=y
CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT=y
CONFIG_KSU_SUSFS_SUS_KSTAT=y
CONFIG_KSU_SUSFS_SUS_OVERLAYFS=n # Often disabled for simplicity/compatibility
CONFIG_KSU_SUSFS_TRY_UMOUNT=y
CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT=y
CONFIG_KSU_SUSFS_SPOOF_UNAME=y
CONFIG_KSU_SUSFS_ENABLE_LOG=n # Disable logs for release builds unless debugging
CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y
CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y
CONFIG_KSU_SUSFS_OPEN_REDIRECT=y
CONFIG_KSU_SUSFS_SUS_SU=n

# Additional FS Settings often needed by SUSFS/AnyKernel
CONFIG_TMPFS_XATTR=y
CONFIG_TMPFS_POSIX_ACL=y
CONFIG_OVERLAY_FS=y # Ensure OverlayFS is enabled if needed by AnyKernel or other features
CONFIG_OVERLAY_FS_REDIRECT_DIR=y
CONFIG_OVERLAY_FS_METACOPY=y

# Network related for potential module usage
CONFIG_IP_NF_TARGET_TTL=m # Build as modules if possible
CONFIG_IP6_NF_TARGET_HL=m
CONFIG_IP6_NF_MATCH_HL=m

# Performance & Power Management Tweaks (Examples - Adjust as needed)
# Scheduler
CONFIG_SCHED_CLASS_EXT=y
CONFIG_SMP=y
CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
CONFIG_MSM_PERFORMANCE=y
# Power management
CONFIG_NO_HZ_IDLE=y
CONFIG_PM_SLEEP_SMP=y
CONFIG_ENERGY_MODEL=y
CONFIG_PM_AUTOSLEEP=y
# Disable excessive debugging for release builds
CONFIG_DEBUG_KERNEL=n
CONFIG_DYNAMIC_DEBUG=n
CONFIG_DEBUG_INFO=n
CONFIG_DETECT_HUNG_TASK=n
CONFIG_SCHED_DEBUG=n
CONFIG_SCHEDSTATS=n
CONFIG_TIMER_STATS=n
CONFIG_PROVE_LOCKING=n
CONFIG_LOCKDEP=n
CONFIG_DEBUG_PREEMPT=n # Corrected typo from original
# CONFIG_LOCK_STAT=n # Optional, disable if not needed
# CONFIG_DEBUG_FS=n # Optional, disable if not needed

EOF
            echo "Configuration settings added."
          else
            echo "KSU/SUSFS configuration settings marker found. Skipping addition."
          fi

      - name: Apply Build System Modifications
        run: |
          KERNEL_PLATFORM_DIR="${{ env.MODEL }}/kernel_platform"
          echo "Changing to kernel platform directory: $KERNEL_PLATFORM_DIR..."
          cd "$KERNEL_PLATFORM_DIR"
          echo "Applying build system modifications (sed/perl)..."
          DEFCONFIG_PATH="./common/arch/arm64/configs/gki_defconfig"

          # LTO Configuration (ensure THIN LTO is preferred)
          # Ensure LTO is enabled, change only if currently 'n'
          sed -i 's/CONFIG_LTO=n/CONFIG_LTO=y/' "$DEFCONFIG_PATH"
          # Prefer THIN LTO over FULL or NONE if LTO is enabled
          sed -i 's/CONFIG_LTO_CLANG_FULL=y/CONFIG_LTO_CLANG_THIN=y/' "$DEFCONFIG_PATH"
          sed -i 's/CONFIG_LTO_CLANG_NONE=y/CONFIG_LTO_CLANG_THIN=y/' "$DEFCONFIG_PATH"
          # If LTO was just enabled, ensure THIN is selected
          if ! grep -q "CONFIG_LTO_CLANG_THIN=y" "$DEFCONFIG_PATH" && grep -q "CONFIG_LTO=y" "$DEFCONFIG_PATH"; then
             echo "CONFIG_LTO_CLANG_THIN=y" >> "$DEFCONFIG_PATH"
             echo "Added CONFIG_LTO_CLANG_THIN=y as LTO was enabled."
          fi

          # Build config and versioning modifications
          # Only remove check_defconfig if it exists
          sed -i '/check_defconfig/d' ./common/build.config.gki || echo "check_defconfig not found in common/build.config.gki (or already removed)."
          # Remove '-dirty' suffix from version string scripts
          for script in ./common/scripts/setlocalversion ./msm-kernel/scripts/setlocalversion ./external/dtc/scripts/setlocalversion ./build/kernel/kleaf/workspace_status_stamp.py; do
            if [ -f "$script" ]; then
              sed -i 's/-dirty//g' "$script" || echo "Could not remove -dirty from $script"
            else
              echo "Version script not found: $script"
            fi
          done
          # Specific modification for stamp.bzl if needed
          sed -i "/stable_scmversion_cmd/s/-maybe-dirty//g" ./build/kernel/kleaf/impl/stamp.bzl || echo "stamp.bzl not found or pattern '-maybe-dirty' not matched."


          # Oplus build script modifications (if they exist and are used)
          OPLUS_SETUP_SH="./oplus/build/oplus_setup.sh"
          if [ -f "$OPLUS_SETUP_SH" ]; then
             # Ensure LTO=thin is exported if LTO is used
             sed -i '/echo "LTO \$LTO "/i export LTO=thin' "$OPLUS_SETUP_SH" || echo "oplus_setup.sh LTO line not found or pattern changed."
             # Disable image repacking if done by AnyKernel
             sed -i 's/export REPACK_IMG=true/export REPACK_IMG=false/g' "$OPLUS_SETUP_SH" || echo "oplus_setup.sh REPACK_IMG line not found or pattern changed."
          else
             echo "Oplus setup script not found: $OPLUS_SETUP_SH"
          fi

          # Hardcode UTS_VERSION timestamp (Optional: Consider removing or making dynamic)
          TIMESTAMP_STR="#1 SMP PREEMPT $(date -u +'%a %b %d %H:%M:%S UTC %Y')" # Use current build time
          # TIMESTAMP_STR="#1 SMP PREEMPT Thu Mar 05 04:20:00 UTC 2025" # Or keep your fixed timestamp
          echo "Setting UTS_VERSION timestamp to: $TIMESTAMP_STR"
          for script in ./common/scripts/mkcompile_h ./msm-kernel/scripts/mkcompile_h; do
             if [ -f "$script" ]; then
                # Use perl for robust replacement across lines if needed
                perl -pi -e 's{UTS_VERSION=\".*?\"; # Set by build script}{UTS_VERSION="'"$TIMESTAMP_STR"'"; # Set by build script}' "$script" || \
                perl -pi -e 's{UTS_VERSION=\"\$\(echo \$UTS_VERSION \$CONFIG_FLAGS \$TIMESTAMP \| cut -b -\$UTS_LEN\)\"}{UTS_VERSION="'"$TIMESTAMP_STR"'"}' "$script" || \
                echo "Could not set timestamp in $script"
             else
                echo "Timestamp script not found: $script"
             fi
          done

          # Add parallel make jobs to internal Makefiles (Use with caution - Bazel should handle top-level parallelism)
          # This might be unnecessary or cause issues if Bazel/Kleaf manages parallelism effectively.
          # echo "Attempting to add parallel jobs (-j) to internal Makefiles..."
          # find . -path ./out -prune -o -type f \( -name 'Makefile' -o -name 'makefile' -o -name '*.mk' \) -exec sed -i 's/\($(MAKE)\|make\)\(\s\|$\)/\1 -j$(nproc)\2/g' {} + || echo "Failed to add parallel jobs to some Makefiles (might be harmless)."

          echo "Build system modifications applied."

      - name: Setup Ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: ${{ github.job }}-${{ env.BRANCH }}-${{ github.ref }} # Cache key based on job, branch, ref
          max-size: 2G # Adjust cache size as needed

      - name: Build the Kernel
        run: |
          echo "Changing to source base directory: ${{ env.MODEL }}..."
          cd "${{ env.MODEL }}" # Base directory where 'kernel_platform' resides

          echo "Building the kernel for SOC: ${{ env.SOC }}..."
          # Clear system caches before heavy build
          echo "Clearing system caches..."
          sync; sudo sh -c 'echo 3 > /proc/sys/vm/drop_caches'

          # Remove potentially stale ABI files before build
          echo "Removing potentially stale ABI files..."
          rm -f ./kernel_platform/common/android/abi_gki_protected_exports_* || true
          rm -f ./kernel_platform/msm-kernel/android/abi_gki_protected_exports_* || true

          # Determine build type and arguments (Bazel/Kleaf is expected for pineapple/6.1)
          BUILD_TYPE="gki" # Default for modern OnePlus GKI builds
          BAZEL_CMD=("./kernel_platform/build/android/prepare_bazel.sh") # Bazel setup script
          BAZEL_ARGS=("build" "//common:kernel_aarch64_dist") # Common GKI build target
          BUILD_SCRIPT="./kernel_platform/build_with_bazel.py" # Main build script

          # Add common Bazel flags
          BUILD_FLAGS=(
            "--jobs=$(nproc --all)"
            "--lto=thin"
            "--config=fast" # Often speeds up builds
            "--config=stamp" # Ensure version stamping
            # Add any other necessary Bazel flags here
          )

          # SOC-specific adjustments (Example - 'sun' is commented out as SOC is 'pineapple')
          # if [ "${{ env.SOC }}" == "sun" ]; then
          #   BUILD_TYPE="perf" # Example: Different build type for 'sun'
          #   BAZEL_ARGS=("build" "//msm-kernel:kernel_aarch64_dist") # Example: Different target for 'sun'
          #   BUILD_FLAGS+=("--config=debug") # Example: Add debug flags for 'sun'
          #   echo "Using build type: perf with specific args for sun SOC"
          # else
          #    echo "Using build type: $BUILD_TYPE for ${{ env.SOC }} SOC"
          # fi

          echo "Using build script: $BUILD_SCRIPT"
          echo "Build target: ${BAZEL_ARGS[@]}"
          echo "Build flags: ${BUILD_FLAGS[@]}"

          # Start resource monitor in background for debugging CI resource issues
          (stdbuf -oL bash -c '
            while true; do
              echo "=== Resource Monitor Tick $(date) ==="
              free -h; echo "---"; df -h; echo "---"; ccache -s; echo "---"; top -b -n 1 | head -n 20
              echo "===================================="
              sleep 120 # Check every 2 minutes
            done
          ') &
          MONITOR_PID=$!
          trap "echo 'Stopping resource monitor...'; kill $MONITOR_PID || true" EXIT # Ensure monitor is killed on exit

          # Execute the build command
          # 1. Prepare Bazel environment (if script exists)
          if [ -f "${BAZEL_CMD[0]}" ]; then
             echo "Running Bazel preparation script..."
             "${BAZEL_CMD[@]}"
          fi

          # 2. Run the main Bazel build script
          if [ -f "$BUILD_SCRIPT" ]; then
             echo "Running Bazel build..."
             # Example invocation (adjust based on actual script requirements)
             # Might need --dist_dir argument
             "$BUILD_SCRIPT" ${BAZEL_ARGS[@]} -- ${BUILD_FLAGS[@]}
             # Alternative structure if build_with_bazel.py takes different args:
             # "$BUILD_SCRIPT" -t ${{ env.SOC }} $BUILD_TYPE "${BUILD_FLAGS[@]}" -o "$(pwd)/out/dist"
          else
             # Fallback (less likely for modern kernels)
             echo "Bazel script $BUILD_SCRIPT not found. Attempting legacy build..."
             # LTO=thin ./kernel_platform/oplus/build/oplus_build_kernel.sh ${{ env.SOC }} "$BUILD_TYPE"
             echo "ERROR: Cannot find appropriate build script!"
             exit 1
          fi

          BUILD_EXIT_CODE=$? # Capture exit code

          echo "Kernel build process finished with exit code: $BUILD_EXIT_CODE"
          # Stop monitor explicitly
          kill $MONITOR_PID || true

          # Check build result
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "ERROR: Kernel build failed!"
            exit 1
          fi

      - name: Locate Kernel Image and Copy to AnyKernel3
        run: |
          echo "Locating kernel image..."
          # Common Bazel output locations for GKI kernel image
          # Adjust paths based on your specific build script output structure
          KERNEL_IMAGE_CANDIDATES=(
            "${{ env.MODEL }}/out/android-kernel/dist/Image" # Common Kleaf dist location
            "${{ env.MODEL }}/out/dist/Image" # Older Bazel dist location
            "${{ env.MODEL }}/kernel_platform/out/android-kernel-*-*/dist/Image" # Another possible Kleaf structure
          )
          KERNEL_IMAGE=""
          for path in "${KERNEL_IMAGE_CANDIDATES[@]}"; do
             # Use find to handle potential wildcard expansion safely
             found_path=$(find . -path "$path" -print -quit)
             if [[ -n "$found_path" && -f "$found_path" ]]; then
                KERNEL_IMAGE="$found_path"
                echo "Found kernel image at: $KERNEL_IMAGE"
                break
             fi
          done

          if [ -z "$KERNEL_IMAGE" ] || [ ! -f "$KERNEL_IMAGE" ]; then
             echo "ERROR: Kernel image (Image) not found in expected output directories!"
             echo "Searched paths:"
             printf '%s\n' "${KERNEL_IMAGE_CANDIDATES[@]}"
             echo "Listing contents of potential output directories:"
             ls -R "${{ env.MODEL }}/out/" || true
             exit 1
          fi

          ANYKERNEL_DIR="AnyKernel3" # Relative path to AnyKernel3 checkout at the workspace root
          echo "Copying $KERNEL_IMAGE to $ANYKERNEL_DIR/Image"
          cp "$KERNEL_IMAGE" "$ANYKERNEL_DIR/Image"

          # Optionally copy Modules etc. if needed by AnyKernel3 script
          # Example: find "${{ env.MODEL }}/out/..." -name '*.ko' -exec cp {} "$ANYKERNEL_DIR/modules/..." \;

      - name: Create AnyKernel3 ZIP File
        id: create_zip # Give step an ID
        run: |
          echo "Navigating to AnyKernel3 directory..."
          cd AnyKernel3 # Assumes AnyKernel3 was cloned at the workspace root

          # Construct the zip file name using hardcoded env vars and outputs
          # Example: OP13r-A14-6.1-KSU11xxx-SUSFS-YYYYMMDD-AnyKernel3.zip
          ZIP_NAME="${{ env.MODEL }}-A${{ env.ANDROID_VERSION }}-${{ env.KERNEL_VERSION }}-KSU${{ steps.add_kernelsu.outputs.ksu_version_num }}-SUSFS-${{ steps.set_build_date.outputs.build_date }}${{ github.event.inputs.release_tag_suffix }}-AnyKernel3.zip"

          echo "Creating AnyKernel3 zip file: $ZIP_NAME..."
          # Use -r for recursive, -9 for best compression, exclude .git related files
          zip -r9 "../$ZIP_NAME" ./* -x ".git/*" ".github/*" "README.md"

          echo "Zip file created: ../$ZIP_NAME"
          # Output the zip name for the release job
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: kernel-${{ env.MODEL }}-${{ steps.set_build_date.outputs.build_date }}
          path: |
            *.zip # Upload the zip file created in the previous step (it's now in the workspace root)
          if-no-files-found: error # Fail the workflow if the zip isn't found

  release:
    # Only run if the build job succeeded and the user requested a release
    needs: build-kernel-op13r
    if: github.event.inputs.make_release == true && needs.build-kernel-op13r.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to create releases

    steps:
      - name: Set Release Variables
        id: release_vars
        run: |
          KSU_VERSION="${{ needs.build-kernel-op13r.outputs.ksu_version }}"
          BUILD_DATE="${{ needs.build-kernel-op13r.outputs.build_date }}"
          ZIP_NAME="${{ needs.build-kernel-op13r.outputs.zip_name }}"
          # Create a tag name, e.g., OP13r-20240315-ksu11xxx
          TAG_NAME="${{ env.MODEL }}-${BUILD_DATE}-ksu${KSU_VERSION}${GITHUB_EVENT_INPUTS_RELEASE_TAG_SUFFIX}"
          # Create a release name, e.g., OnePlus 13R Kernel [2024-03-15 | KSU: 11xxx]
          RELEASE_NAME="${{ env.MODEL }} Kernel [${BUILD_DATE} | KSU: ${KSU_VERSION}]${GITHUB_EVENT_INPUTS_RELEASE_TAG_SUFFIX}"

          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "release_name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
          echo "zip_name=${ZIP_NAME}" >> $GITHUB_OUTPUT

      - name: Download Kernel Zip Artifact
        uses: actions/download-artifact@v4
        with:
          name: kernel-${{ env.MODEL }}-${{ needs.build-kernel-op13r.outputs.build_date }} # Match the upload artifact name
          # No path specified, defaults to workspace root

      - name: Display Downloaded Files
        run: ls -l

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2 # Use v2 for latest features
        with:
          tag_name: ${{ steps.release_vars.outputs.tag_name }}
          name: ${{ steps.release_vars.outputs.release_name }}
          body: |
            ## OnePlus 13R (${{ env.SOC }}) Custom Kernel Build

            **Base:** OnePlus Android ${{ env.ANDROID_VERSION }} (${{ env.BRANCH }})
            **Kernel Version:** Linux ${{ env.KERNEL_VERSION }}
            **KernelSU Version:** ${{ needs.build-kernel-op13r.outputs.ksu_version }} (Next Branch)
            **SUSFS:** Included (Branch: gki-${{ env.ANDROID_VERSION }}-${{ env.KERNEL_VERSION }})
            **Build Date:** ${{ needs.build-kernel-op13r.outputs.build_date }}

            **Features:**
            - KernelSU-Next integration for root access.
            - SUSFS integration for hiding root/modules.
            - Based on official OnePlus sources.
            - Built with Clang & LTO (Thin).
            - Includes AnyKernel3 packaging.

            **File attached:** `${{ steps.release_vars.outputs.zip_name }}`

            **Note:** Flash this zip using a custom recovery (e.g., TWRP/OrangeFox). Always back up your data first.
          files: |
            ${{ steps.release_vars.outputs.zip_name }} # Upload the specific zip file
          # draft: false # Set to true to create a draft release
          # prerelease: false # Set to true to mark as pre-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Required for creating releases
